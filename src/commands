#pragma once
#include <Arduino.h>
#include "config"
#include "conponent"
#include "servo"
#include "l3str"

namespace HeraCross
{
struct CommandFunction
{
    using signature = bool(const int, L3Str* const);
    CommandFunction(const L3Str& name, const int argc, signature* const func) : _name(name), _argc(argc), _func(func) {}
    const L3Str _name;
    const int _argc;
    signature* const _func;
};
class CommandEngine
{
    private:
    CommandFunction *_table;
    int _cmd_count;
    public:
    CommandEngine(CommandFunction *table,int cmd_count) : _table(table), _cmd_count(cmd_count){}
    void TryRun(const String& raw_cmd)
    {
        //Spilt
        L3Str args[CMD_ARG_SIZE]={};
        int args_len = 0;
        unsigned raw_len  = raw_cmd.length() - 1;
        if(raw_len > 0)
        {
            unsigned i = 0;
            do
            {
                if(!(raw_cmd[i]==' '||raw_cmd[i]=='\0'||raw_cmd[i]=='\n'))
                {
                    args[args_len]+=raw_cmd[i];
                }
                else
                {
                    args_len++;
                }
                i++;
            }while(i<raw_len);
            args_len++;
        }
        //Find
        unsigned int l=0,r=_cmd_count;
        while(l<r)
        {
            unsigned int mid = (l+r) >> 1;
            if(_table[mid]._name < args[0]) l = mid + 1;
            else r=mid;
        }
        //Execute
        if(l<_cmd_count && _table[l]._name==args[0])
        {
            if(_table[l]._argc==args_len)
            {
                bool ret = _table[l]._func(args_len,args);
                if(ret)
                {
                    TRACESV("Command executed", args[0]);
                }
                else 
                {
                    TRACESV("Command failed", args[0]);
                }
            }
            else
            {
                TRACESV("Wrong number of arguments", args[0]);
            }
        }
        else 
        {
            TRACESV("Unknown command: " , args[0]);
        }
    }
};


class Commands : public CommandEngine
{
public:
    using arg_list = L3Str*;
    const static CommandFunction cmd_table[];
    const static int cmd_count;

    Commands() : CommandEngine(cmd_table,cmd_count) {}

    //tgd: Tong on/off/grab
    static bool tong_digital(const int argc,const arg_list argv)
    {
        auto& arg = argv[1];
        if (arg == "on")
        {
            servo_tong.TurnMax();
        }
        else if (arg == "off")
        {
            servo_tong.TurnMin();
        }
        else if (arg == "grb")
        {
            servo_tong.SetPulse(SERVO_TONG_GRAB);
        }
        else return false;

        return true;
    }
    //nkd: Neck on/off
    static bool neck_digital(const int argc,const arg_list argv)
    {
        auto& arg = argv[1];
        if (arg == "on")
        {
            servo_neck.TurnMax();
        }
        else if (arg == "off")
        {
            servo_neck.TurnMin();
        }
        else return false;

        return true;
    }
    //cld: Cleave on/off
    static bool cleave_digital(const int argc,const arg_list argv)
    {
        auto& arg = argv[1];
        if (arg == "on")
        {
            servo_cleave.TurnMax();
        }
        else if (arg == "off")
        {
            servo_cleave.TurnMin();
        }
        else if (arg == "clm")
        {
            servo_cleave.SetAngle(SERVO_CLEAVE_CLIMB);
        }
        else if (arg == "grb")
        {
            servo_cleave.SetAngle(SERVO_CLEAVE_GRAB);
        }
        else 
        {
            TRACESV("arg:", arg);
            return false;
        }

        return true;
    }
    //mld: Motor left foward/backward/off/brake
    static bool motor_l_digital(const int argc,const arg_list argv)
    {
        return motor_digital(motor_l, argc, argv);
    }
    //mrd: Motor right foward/backward/off/brake
    static bool motor_r_digital(const int argc,const arg_list argv)
    {
        return motor_digital(motor_r, argc, argv);
    }
    //msd: Motor step forward/backward/off/brake
    static bool motor_step_digital(const int argc,const arg_list argv)
    {
        return motor_digital(motor_l,argc,argv) && motor_digital(motor_r,argc,argv);
    }
    //scn: Scaner scan action
    static bool scan(const int argc,const arg_list argv)
    {
        if (scanner.get())
        {
            Serial.print("Target:");
            Serial.println(colornames[scanner.target]);
            Serial.print("Seq:");
            for (int i = 0; i < COLOR_SEQ_COUNT; i++)
            {
                Serial.print(colornames[scanner.seq[i]]);
                Serial.print(",");
            }
            Serial.println();
            screen.ShowColor(scanner.target, scanner.seq);
            return true;
        }
        return false;
    }

    //grb: Grab action
    static bool grab(const int argc,const arg_list argv)
    {
        servo_neck.SetAngle(SERVO_NECK_MID,2);
        servo_tong.SetPulse(SERVO_TONG_GRAB);
        servo_cleave.SetAngle(SERVO_CLEAVE_GRAB,2);
        delay(1000);
        servo_tong.TurnMin();
        delay(400);
        servo_cleave.TurnMax();
        delay(200);
        servo_neck.TurnMin();
        return true;
    }

    //clm: climb action
    //deprecated
    static bool climb(const int argc,const arg_list argv)
    {
        servo_neck.TurnMin();

        // 第一个台阶
        motor_l.Forward();
        motor_r.Forward();
        delay(250); // 这个时间要够短，前轮刚好上去就行
        motor_l.Off();
        motor_r.Off();

        servo_cleave.SetAngle(SERVO_CLEAVE_CLIMB,10);
        motor_l.Forward();
        motor_r.Forward();
        delay(400); // 这里也要短一点，不要影响下一个台阶
        motor_l.Off();
        motor_r.Off();

        servo_cleave.TurnMax();

        // 第二个台阶
        motor_l.Forward();
        motor_r.Forward();
        delay(500); // 这个时间要够短，前轮刚好上去就行
        motor_l.Off();
        motor_r.Off();

        servo_cleave.TurnMax();
        motor_l.Forward();
        motor_r.Forward();
        delay(550);
        motor_l.Off();
        motor_r.Off();

        // 到此为止,已经爬过了两个台阶

        // 下台阶
        motor_l.Forward();
        motor_r.Forward();
        delay(400);
        // motor_l.Brake();
        // motor_r.Brake();
        // delay(400); // 等稳定

        safe_cleave_up(0,{});

        motor_l.Off();
        motor_r.Off();

        return true;
    }
    //scu: safe cleave up action
    static bool safe_cleave_up(const int argc,const arg_list argv)
    {
        servo_neck.SetAngle(SERVO_NECK_MID);
        delay(800);
        servo_cleave.TurnMax();
        delay(700);
        servo_neck.TurnMax();
        return true;
    }
    //dnd: dont die action
    static bool dont_die(const int argc,const arg_list argv)
    {
        servo_cleave.TurnMin();

        motor_l.Forward();
        motor_r.Forward();
        delay(100);
        motor_l.Off();
        motor_r.Off();

        servo_neck.SetAngle(SERVO_NECK_MID, 30);

        servo_cleave.TurnMax();

        servo_neck.TurnMax(); // 最后朝后
        return true;
    }

    //Utils
    //Servo analog
    static void servo_analog(ServoBase& servo, const int argc, const arg_list argv)
    {
        auto& arg = argv[1];
        int angle = static_cast<uint16_t>(arg);
        servo.SetAngle(angle);
    }
    //Motor digital
    static bool motor_digital(Motor& motor, const int argc, const arg_list argv)
    {
        auto& arg = argv[1];
        if (arg == "f")
        {
            motor.Forward();
        }
        else if (arg == "b")
        {
            motor.Backward();
        }
        else if (arg == "ff")
        {
            motor.ForwardFullSpeed();
        }
        else if (arg == "bb")
        {
            motor.BackwardFullSpeed();
        }
        else if (arg == "off")
        {
            motor.Off();
        }
        else if (arg == "brk")
        {
            motor.Brake();
        }
        else return false;

        return true;
    }
};
const CommandFunction Commands::cmd_table[] = 
    {
        {"cld", 2, Commands::cleave_digital},   // Cleave on/off/clm/grb
        {"clm", 1, Commands::climb},            // Climb action (deprecated)
        {"dnd", 1, Commands::dont_die},         // Dont die action
        {"grb", 1, Commands::grab},             // Grab action
        {"mld", 2, Commands::motor_l_digital},  // Motor left forward/backward/off/brake
        {"mrd", 2, Commands::motor_r_digital},  // Motor right forward/backward/off/brake
        {"msd", 2, Commands::motor_step_digital}, // Motor step forward/backward/off/brake
        {"nkd", 2, Commands::neck_digital},     // Neck on/off
        {"scn", 1, Commands::scan},             // Scanner scan action
        {"scu", 1, Commands::safe_cleave_up},   // Safe cleave up action
        {"tgd", 2, Commands::tong_digital}      // Tong on/off/grab
    };
const int Commands::cmd_count = sizeof(cmd_table) / sizeof(cmd_table[0]);
}
HeraCross::Commands commands;